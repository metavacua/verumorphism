;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Data Structures (Minimal for Prototype) - Enhanced Node
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defclass relnet-node ()
  ((name :initarg :name :accessor relnet-node-name)
   (type :initarg :type :accessor relnet-node-type))
  (:documentation "Represents a node in the relational network, enhanced with a type.

Slots:
  - NAME: The symbolic name of the node.
  - TYPE: The type of the node (e.g., 'formula', 'term')."))

(defvar *knowledge-base* nil
  "The global knowledge base for the prover. In this prototype, it is not
used beyond being passed to axiom and rule functions.")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Axioms (con_R and incon_L - Minimal for Prototype)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun axiom-con-r (kb)
  "A minimal implementation of the 'Consistency Right' (con_R) proof axiom.

Parameters:
  - KB: The knowledge base (ignored).

Returns:
  - The keyword :PROVEN."
  (declare (ignore kb))
  (format t "Proof Thread: Applying con_R axiom - Axiomatically Proven.~%")
  :proven)

(defun axiom-incon-l (kb)
  "A minimal implementation of the 'Inconsistency Left' (incon_L) refutation axiom.

Parameters:
  - KB: The knowledge base (ignored).

Returns:
  - The keyword :REFUTED."
  (declare (ignore kb))
  (format t "Refutation Thread: Applying incon_L axiom - Axiomatically Refuted.~%")
  :refuted)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Rules (Dependence & Independence - Minimal for Prototype)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun rule-dependence-r (kb)
  "Simulates the 'Dependence Right' (*DEP*R) rule, representing a logical AND.

Parameters:
  - KB: The knowledge base.

Returns:
  - :RULE-APPLIED on success, NIL on failure."
  (format t "Proof Thread: Attempting rule *DEP*R (Dependence Right).~%")
  (let ((proof1-result (axiom-con-r kb))
        (proof2-result (axiom-con-r kb)))
    (if (and (eq proof1-result :proven) (eq proof2-result :proven))
        (progn
          (format t "Proof Thread: Rule *DEP*R applied successfully - Proven (*DEP* con con).~%")
          :rule-applied)
        (progn
          (format t "Proof Thread: Rule *DEP*R failed to apply.~%")
          nil))))

(defun rule-dependence-l (kb)
  "Simulates the 'Dependence Left' (*DEP*L) rule, representing a logical AND.

Parameters:
  - KB: The knowledge base.

Returns:
  - :RULE-APPLIED on success, NIL on failure."
  (format t "Refutation Thread: Attempting rule *DEP*L (Dependence Left).~%")
  (let ((refute1-result (axiom-incon-l kb))
        (refute2-result (axiom-incon-l kb)))
    (if (and (eq refute1-result :refuted) (eq refute2-result :refuted))
        (progn
          (format t "Refutation Thread: Rule *DEP*L applied successfully - Refuted (*DEP* incon incon).~%")
          :rule-applied)
        (progn
          (format t "Refutation Thread: Rule *DEP*L failed to apply.~%")
          nil))))

(defun rule-independence-r (kb &key axiom-con)
  "Simulates the 'Independence Right' (*IND*R) rule with early exit logic.
This rule represents a logical OR and returns detailed evaluation information.

Parameters:
  - KB: The knowledge base.
  - AXIOM-CON (Keyword, Optional): A function for proving premises.

Returns:
  - Multiple values on success or failure, including status, which premise succeeded,
    and which premises were evaluated."
  (format t "Proof Thread: Attempting rule *IND*R (Independence Right).~%")
  (let ((premise1-evaluated nil)
        (premise2-evaluated nil))
    (let ((proof1-result (funcall (or axiom-con #'axiom-con-r) kb)))
      (setf premise1-evaluated t)
      (if (eq proof1-result :proven)
          (progn
            (format t "Proof Thread: Rule *IND*R applied successfully - Proven (*IND* con X) (via first premise).~%")
            (return-from rule-independence-r (values :rule-applied :premise1-satisfied :premises-evaluated-flags (list premise1-evaluated premise2-evaluated))))
          (let ((proof2-result (funcall (or axiom-con #'axiom-con-r) kb)))
            (setf premise2-evaluated t)
            (if (eq proof2-result :proven)
                (progn
                  (format t "Proof Thread: Rule *IND*R applied successfully - Proven (*IND* X con) (via second premise).~%")
                  (return-from rule-independence-r (values :rule-applied :premise2-satisfied :premises-evaluated-flags (list premise1-evaluated premise2-evaluated))))
                (progn
                  (format t "Proof Thread: Rule *IND*R failed to apply.~%")
                  (return-from rule-independence-r (values nil nil :premises-evaluated-flags (list premise1-evaluated premise2-evaluated))))))))))


(defun rule-independence-l (kb &key axiom-incon)
  "Simulates the 'Independence Left' (*IND*L) rule with early exit logic.
This rule represents a logical OR and returns detailed evaluation information.

Parameters:
  - KB: The knowledge base.
  - AXIOM-INCON (Keyword, Optional): A function for refuting premises.

Returns:
  - Multiple values on success or failure, including status, which premise succeeded,
    and which premises were evaluated."
  (format t "Refutation Thread: Attempting rule *IND*L (Independence Left).~%")
  (let ((premise1-evaluated nil)
        (premise2-evaluated nil))
    (let ((refute1-result (funcall (or axiom-incon #'axiom-incon-l) kb)))
      (setf premise1-evaluated t)
      (if (eq refute1-result :refuted)
          (progn
            (format t "Refutation Thread: Rule *IND*L applied successfully - Refuted (*IND* incon X) (via first premise).~%")
            (return-from rule-independence-l (values :rule-applied :premise1-satisfied :premises-evaluated-flags (list premise1-evaluated premise2-evaluated))))
          (let ((refute2-result (funcall (or axiom-incon #'axiom-incon-l) kb)))
            (setf premise2-evaluated t)
            (if (eq refute2-result :refuted)
                (progn
                  (format t "Refutation Thread: Rule *IND*L applied successfully - Refuted (*IND* X incon) (via second premise).~%")
                  (return-from rule-independence-l (values :rule-applied :premise2-satisfied :premises-evaluated-flags (list premise1-evaluated premise2-evaluated))))
                (progn
                  (format t "Refutation Thread: Rule *IND*L failed to apply.~%")
                  (return-from rule-independence-l (values nil nil :premises-evaluated-flags (list premise1-evaluated premise2-evaluated))))))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Thread Functions (Proof and Refutation - Minimal for Prototype)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar *proof-result* nil
  "Holds the result from the proof thread.")
(defvar *refutation-result* nil
  "Holds the result from the refutation thread.")
(defvar *termination-flag* nil
  "A flag to coordinate the termination of the proof and refutation threads.")


(defun proof-thread-function ()
  "The main function for the proof-seeking thread.
Sequentially applies axioms and rules to find a proof.

Returns:
  - :PROVEN on success, :UNKNOWN on failure."
  (format t "Proof Thread: Starting.~%")
  (sleep 1)

  ;; 1. Try axiom con_R
  (let ((axiom-con-r-result (axiom-con-r *knowledge-base*)))
    (when (eq axiom-con-r-result :proven)
      (setf *proof-result* :proven)
      (setf *termination-flag* :proof-terminated)
      (format t "Proof Thread: Terminating (via con_R axiom).~%")
      (return-from proof-thread-function :proven)))

  ;; 2. Try rule *DEP*R
  (let ((rule-dep-r-result (rule-dependence-r *knowledge-base*)))
    (when (eq rule-dep-r-result :rule-applied)
      (setf *proof-result* :proven)
      (setf *termination-flag* :proof-terminated)
      (format t "Proof Thread: Terminating (via rule *DEP*R).~%")
      (return-from proof-thread-function :proven)))

  ;; 3. Try rule *IND*R (using default axiom-con-r)
  (multiple-value-bind (rule-ind-r-result premise-satisfied flags)
      (rule-independence-r *knowledge-base*)
    (declare (ignore premise-satisfied flags))
    (when (eq rule-ind-r-result :rule-applied)
      (setf *proof-result* :proven)
      (setf *termination-flag* :proof-terminated)
      (format t "Proof Thread: Terminating (via rule *IND*R).~%")
      (return-from proof-thread-function :proven)))


  ;; 4. No proof found
  (format t "Proof Thread: No proof found in this iteration.~%")
  (setf *proof-result* :unknown)
  (setf *termination-flag* :proof-terminated)
  (format t "Proof Thread: Terminating (no proof).~%")
  :unknown)



(defun refutation-thread-function ()
  "The main function for the refutation-seeking thread.
Sequentially applies axioms and rules to find a refutation.

Returns:
  - :REFUTED on success, :UNKNOWN on failure."
  (format t "Refutation Thread: Starting.~%")
  (sleep 1.5)

  ;; 1. Try axiom incon_L
  (let ((axiom-incon-l-result (axiom-incon-l *knowledge-base*)))
    (when (eq axiom-incon-l-result :refuted)
      (setf *refutation-result* :refuted)
      (setf *termination-flag* :refutation-terminated)
      (format t "Refutation Thread: Terminating (via incon_L axiom).~%")
      (return-from refutation-thread-function :refuted)))

  ;; 2. Try rule *DEP*L
  (let ((rule-dep-l-result (rule-dependence-l *knowledge-base*)))
    (when (eq rule-dep-l-result :rule-applied)
      (setf *refutation-result* :refuted)
      (setf *termination-flag* :refutation-terminated)
      (format t "Refutation Thread: Terminating (via rule *DEP*L).~%")
      (return-from refutation-thread-function :refuted)))

  ;; 3. Try rule *IND*L (using default axiom-incon-l)
  (multiple-value-bind (rule-ind-l-result premise-satisfied flags)
      (rule-independence-l *knowledge-base*)
    (declare (ignore premise-satisfied flags))
    (when (eq rule-ind-l-result :rule-applied)
      (setf *refutation-result* :refuted)
      (setf *termination-flag* :refutation-terminated)
      (format t "Refutation Thread: Terminating (via rule *IND*L).~%")
      (return-from refutation-thread-function :refuted)))

  ;; 4. No refutation found
  (format t "Refutation Thread: No refutation found in this iteration.~%")
  (setf *refutation-result* :unknown)
  (setf *termination-flag* :refutation-terminated)
  (format t "Refutation Thread: Terminating (no refutation).~%")
  :unknown)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Parallel Interface and Orchestration (Barebones Prototype)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun initialize-knowledge-base ()
  "Resets the `*knowledge-base*` to an empty state."
  (setf *knowledge-base* nil))

(defun run-prover ()
  "Runs the theorem prover by orchestrating parallel proof and refutation threads.

Returns:
  - :PROVEN if the proof thread finishes first.
  - :REFUTED if the refutation thread finishes first.
  - :UNKNOWN for any other case."
  (format t "Prover: Initializing Knowledge Base.~%")
  (initialize-knowledge-base)

  (format t "Prover: Starting Proof and Refutation Threads.~%")
  (let ((proof-thread (sb-thread:make-thread #'proof-thread-function :name "Proof-Thread"))
        (refutation-thread (sb-thread:make-thread #'refutation-thread-function :name "Refutation-Thread")))

    (format t "Prover: Waiting for termination signal from threads.~%")
    (loop until *termination-flag*
          do (sleep 0.1))

    (format t "Prover: Termination signal received: ~A~%" *termination-flag*)

    (cond ((eq *termination-flag* :proof-terminated)
           (format t "Prover: Proof Thread terminated first. Result: Proven.~%")
           :proven)
          ((eq *termination-flag* :refutation-terminated)
           (format t "Prover: Refutation Thread terminated first. Result: Refuted.~%")
           :refuted)
          (t
           (format t "Prover: Unexpected termination state.~%")
           :unknown))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Unit Tests - Comprehensive and Targeted - ENHANCED - REFACTORED and MODULARIZED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar *test-suite-summary* (make-hash-table)
  "A hash table to store the results of the test suite.
Keys are test categories, and values are hash tables of test results.")

(defun reset-test-summary ()
  "Resets the `*test-suite-summary*` to an empty state before a test run."
  (setf *test-suite-summary* (make-hash-table)))

(defun update-test-summary (test-category test-name result)
  "Records the result of a single test in the `*test-suite-summary*`."
  (let ((category-summary (gethash test-category *test-suite-summary*
                                   (make-hash-table :test #'equal))))
    (setf (gethash test-name category-summary) result)
    (setf (gethash test-category *test-suite-summary*) category-summary)))

(defun format-test-result (test-name pass-fail message)
  "Prints a formatted summary of a single test's result."
  (if pass-fail
      (format t "    Test ~A: PASS~%" test-name) ; Indented for category clarity
      (format t "    Test ~A: FAIL - ~A~%" test-name message))) ; Indented for category clarity

(defun assert-eq (actual expected test-name test-category)
  "Asserts that `actual` is `equal` to `expected`.

Returns:
  - T if the assertion passes, NIL otherwise."
  (let ((pass-fail (equal actual expected))
        (message (format nil "Expected ~A, got ~A" expected actual)))
    (format-test-result test-name pass-fail message)
    (update-test-summary test-category test-name pass-fail)
    pass-fail))

(defun assert-true (condition test-name test-category message)
  "Asserts that a given condition is true.

Returns:
  - T if the condition is true, NIL otherwise."
  (let ((pass-fail condition))
    (format-test-result test-name pass-fail message)
    (update-test-summary test-category test-name pass-fail)
    pass-fail))

(defun assert-rule-applied (result test-name test-category)
  "A specific assertion to check if a rule function returned :rule-applied."
  (assert-true (eq result :rule-applied) test-name test-category (format nil "Expected :rule-applied, got ~A" result)))

(defun assert-axiom-proven (result test-name test-category)
  "A specific assertion to check if an axiom function returned :proven."
  (assert-true (eq result :proven) test-name test-category (format nil "Expected :proven, got ~A" result)))

(defun assert-axiom-refuted (result test-name test-category)
  "A specific assertion to check if an axiom function returned :refuted."
  (assert-true (eq result :refuted) test-name test-category (format nil "Expected :refuted, got ~A" result)))


(defun run-axiom-tests ()
  "A test runner for the axiom-related tests.
It executes each axiom test and reports the aggregated results.

Returns:
  - A cons cell `(PASSED . FAILED)` with the test counts for this category."
  (format t "~%Running Axiom Tests:~%")
  (let ((passed-count 0)
        (failed-count 0))
    (multiple-value-bind (pass? message) (test-axiom-con-r) (if pass? (incf passed-count) (incf failed-count)))
    (multiple-value-bind (pass? message) (test-axiom-incon-l) (if pass? (incf passed-count) (incf failed-count)))
    (format t "~%Axiom Tests Finished. Passed: ~A, Failed: ~A~%" passed-count failed-count)
    (cons passed-count failed-count)))


(defun run-dependence-rule-tests ()
  "A test runner for the dependence rule tests.
It executes each dependence rule test and reports the aggregated results.

Returns:
  - A cons cell `(PASSED . FAILED)` with the test counts for this category."
  (format t "~%Running Dependence Rule Tests:~%")
  (let ((passed-count 0)
        (failed-count 0))
    (multiple-value-bind (pass? message) (test-rule-dependence-r-positive) (if pass? (incf passed-count) (incf failed-count)))
    (multiple-value-bind (pass? message) (test-rule-dependence-r-negative) (if pass? (incf passed-count) (incf failed-count)))
    (multiple-value-bind (pass? message) (test-rule-dependence-l-positive) (if pass? (incf passed-count) (incf failed-count)))
    (multiple-value-bind (pass? message) (test-rule-dependence-l-negative) (if pass? (incf passed-count) (incf failed-count)))
    (format t "~%Dependence Rule Tests Finished. Passed: ~A, Failed: ~A~%" passed-count failed-count)
    (cons passed-count failed-count)))

(defun run-independence-rule-tests ()
  "A test runner for the independence rule tests.
It executes each independence rule test and reports the aggregated results.

Returns:
  - A cons cell `(PASSED . FAILED)` with the test counts for this category."
  (format t "~%Running Independence Rule Tests:~%")
  (let ((passed-count 0)
        (failed-count 0))
    (multiple-value-bind (pass? message) (test-rule-independence-r-premise1-con) (if pass? (incf passed-count) (incf failed-count)))
    (multiple-value-bind (pass? message) (test-rule-independence-r-premise2-con) (if pass? (incf passed-count) (incf failed-count)))
    (multiple-value-bind (pass? message) (test-rule-independence-r-negative) (if pass? (incf passed-count) (incf failed-count)))
    (multiple-value-bind (pass? message) (test-rule-independence-r-early-exit-premise1) (if pass? (incf passed-count) (incf failed-count)))
    (multiple-value-bind (pass? message) (test-rule-independence-l-premise1-incon) (if pass? (incf passed-count) (incf failed-count)))
    (multiple-value-bind (pass? message) (test-rule-independence-l-premise2-incon) (if pass? (incf passed-count) (incf failed-count)))
    (multiple-value-bind (pass? message) (test-rule-independence-l-negative) (if pass? (incf passed-count) (incf failed-count)))
    (multiple-value-bind (pass? message) (test-rule-independence-l-early-exit-premise1) (if pass? (incf passed-count) (incf failed-count)))
    (format t "~%Independence Rule Tests Finished. Passed: ~A, Failed: ~A~%" passed-count failed-count)
    (cons passed-count failed-count)))


(defun run-test-categories ()
  "The main test harness function that orchestrates all test categories.
It calls the specific runners for axioms, dependence rules, and independence rules,
and then prints a final summary of all results.

Side Effects:
  - Prints a detailed test summary to standard output."
  (reset-test-summary)
  (format t "Starting Unit Tests.~%")

  (let ((axiom-results (run-axiom-tests))
        (dependence-rule-results (run-dependence-rule-tests))
        (independence-rule-results (run-independence-rule-tests)))

    (format t "~%--- Test Summary ---~%")
    (format t "Axiom Tests:             Passed: ~A, Failed: ~A~%" (car axiom-results) (cdr axiom-results))
    (format t "Dependence Rule Tests:   Passed: ~A, Failed: ~A~%" (car dependence-rule-results) (cdr dependence-rule-results))
    (format t "Independence Rule Tests: Passed: ~A, Failed: ~A~%" (car independence-rule-results) (cdr independence-rule-results))

    (let ((total-passed (+ (car axiom-results) (car dependence-rule-results) (car independence-rule-results)))
          (total-failed (+ (cdr axiom-results) (cdr dependence-rule-results) (cdr independence-rule-results))))
      (format t "~%Total Tests:           Passed: ~A, Failed: ~A~%" total-passed total-failed))

    (format t "~%--- Failed Test Details ---~%")
    (iterate-test-summary)

    (format t "~%Unit Tests Finished.~%")))


(defun iterate-test-summary ()
  "Iterates through the `*test-suite-summary*` and prints a detailed report,
including a list of failed tests for each category."
  (loop for category being the hash-keys of *test-suite-summary* using (hash-value category-summary)
        do (format t "~%~A Tests:~%" category)
           (loop for test-name being the hash-keys of category-summary using (hash-value result)
                 do (unless result
                      (format t "    Failed Test: ~A~%" test-name)))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Axiom Test Functions - ENHANCED with Assertions - REFACTORED for modularity
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun test-axiom-con-r ()
  "Tests the `axiom-con-r` function.
Returns a pass/fail boolean and the test name for aggregation."
  (let ((result (axiom-con-r *knowledge-base*)))
    (assert-axiom-proven result "axiom-con-r" "Axiom") ; Category "Axiom"
    (values (assert-axiom-proven result "axiom-con-r" "Axiom") "axiom-con-r")))

(defun test-axiom-incon-l ()
  "Tests the `axiom-incon-l` function.
Returns a pass/fail boolean and the test name for aggregation."
  (let ((result (axiom-incon-l *knowledge-base*)))
    (assert-axiom-refuted result "axiom-incon-l" "Axiom") ; Category "Axiom"
    (values (assert-axiom-refuted result "axiom-incon-l" "Axiom") "axiom-incon-l")))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Dependence Rule Test Functions - ENHANCED with Assertions - REFACTORED for modularity
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun test-rule-dependence-r-positive ()
  "Tests the positive case for `rule-dependence-r`.
Returns a pass/fail boolean and the test name for aggregation."
  (let ((result (rule-dependence-r *knowledge-base*)))
    (assert-rule-applied result "rule-dependence-r-positive" "Dependence Rule") ; Category "Dependence Rule"
    (values (assert-rule-applied result "rule-dependence-r-positive" "Dependence Rule") "rule-dependence-r-positive")))

(defun test-rule-dependence-r-negative ()
  "Tests the negative case for `rule-dependence-r`.
Returns a pass/fail boolean and the test name for aggregation."
  (let ((result (rule-dependence-r *knowledge-base*)))
    (assert-rule-applied result "rule-dependence-r-negative" "Dependence Rule") ; Category "Dependence Rule"
    (values (assert-rule-applied result "rule-dependence-r-negative" "Dependence Rule") "rule-dependence-r-negative")))

(defun test-rule-dependence-l-positive ()
  "Tests the positive case for `rule-dependence-l`.
Returns a pass/fail boolean and the test name for aggregation."
  (let ((result (rule-dependence-l *knowledge-base*)))
    (assert-rule-applied result "rule-dependence-l-positive" "Dependence Rule") ; Category "Dependence Rule"
    (values (assert-rule-applied result "rule-dependence-l-positive" "Dependence Rule") "rule-dependence-l-positive")))

(defun test-rule-dependence-l-negative ()
  "Tests the negative case for `rule-dependence-l`.
Returns a pass/fail boolean and the test name for aggregation."
  (let ((result (rule-dependence-l *knowledge-base*)))
    (assert-rule-applied result "rule-dependence-l-negative" "Dependence Rule") ; Category "Dependence Rule"
    (values (assert-rule-applied result "rule-dependence-l-negative" "Dependence Rule") "rule-dependence-l-negative")))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Independence Rule Test Functions - Comprehensive - ENHANCED with Assertions - REFACTORED for modularity
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun test-rule-independence-r-premise1-con ()
  (multiple-value-bind (rule-result premise-satisfied flags)
      (rule-independence-r *knowledge-base*)
    (declare (ignore flags))
    (assert-true (and (eq rule-result :rule-applied) (eq premise-satisfied :premise1-satisfied))
                 "rule-independence-r-premise1-con" "Independence Rule"
                 (format nil "Expected (:rule-applied :premise1-satisfied), got (~A ~A)" rule-result premise-satisfied))
    (values (assert-true (and (eq rule-result :rule-applied) (eq premise-satisfied :premise1-satisfied))
                 "rule-independence-r-premise1-con" "Independence Rule"
                 (format nil "Expected (:rule-applied :premise1-satisfied), got (~A ~A)" rule-result premise-satisfied)) "rule-independence-r-premise1-con")))


(defun test-rule-independence-r-premise2-con ()
  (let ((axiom-con-count 0))
    (flet ((mock-axiom-con-r (kb)
             (declare (ignore kb))
             (incf axiom-con-count)
             (format t "    Mock axiom-con-r called (count: ~A).~%" axiom-con-count)
             (if (= axiom-con-count 2)
                 :proven
                 nil)))
      (multiple-value-bind (rule-result premise-satisfied flags)
          (rule-independence-r *knowledge-base* :axiom-con #'mock-axiom-con-r)
        (declare (ignore flags))
        (assert-true (and (eq rule-result :rule-applied) (eq premise-satisfied :premise2-satisfied))
                     "rule-independence-r-premise2-con" "Independence Rule"
                     (format nil "Expected (:rule-applied :premise2-satisfied), got (~A ~A)" rule-result premise-satisfied))
        (values (assert-true (and (eq rule-result :rule-applied) (eq premise-satisfied :premise2-satisfied))
                     "rule-independence-r-premise2-con" "Independence Rule"
                     (format nil "Expected (:rule-applied :premise2-satisfied), got (~A ~A)" rule-result premise-satisfied)) "rule-independence-r-premise2-con")))))


(defun test-rule-independence-r-negative ()
  (let ((axiom-con-count 0))
    (flet ((mock-axiom-con-r (kb)
             (declare (ignore kb))
             (incf axiom-con-count)
             (format t "    Mock axiom-con-r called (count: ~A) - (Negative Test - Never Proven).~%" axiom-con-count)
             nil))
      (multiple-value-bind (rule-result premise-satisfied flags)
          (rule-independence-r *knowledge-base* :axiom-con #'mock-axiom-con-r)
        (declare (ignore premise-satisfied flags))
        (assert-true (not (eq rule-result :rule-applied))
                     "rule-independence-r-negative" "Independence Rule"
                     (format nil "Expected NIL, got ~A" rule-result))
        (values (assert-true (not (eq rule-result :rule-applied))
                     "rule-independence-r-negative" "Independence Rule"
                     (format nil "Expected NIL, got ~A" rule-result)) "rule-independence-r-negative")))))


(defun test-rule-independence-r-early-exit-premise1 ()
  (let ((axiom-con-count 0)
        (premise2-evaluated-flag nil))

    (flet ((mock-axiom-con-r (kb)
             (declare (ignore kb))
             (incf axiom-con-count)
             (format t "    Mock axiom-con-r called (count: ~A) - (Early Exit Test).~%" axiom-con-count)
             (if (= axiom-con-count 1)
                 :proven
                 (progn
                   (setf premise2-evaluated-flag t)
                   nil))))

      (multiple-value-bind (rule-result premise-satisfied flags)
          (rule-independence-r *knowledge-base* :axiom-con #'mock-axiom-con-r)
        (declare (ignore rule-result premise-satisfied))
        (let ((premise-flags (cdr (cdr (multiple-value-list (rule-independence-r *knowledge-base* :axiom-con #'mock-axiom-con-r))))))
          (assert-true (and (not premise2-evaluated-flag) (eq (car premise-flags) t) (eq (cadr premise-flags) nil))
                       "rule-independence-r-early-exit-premise1" "Independence Rule"
                       "Early Exit Failed or Premise Flags Incorrect.")
          (values (assert-true (and (not premise2-evaluated-flag) (eq (car premise-flags) t) (eq (cadr premise-flags) nil))
                       "rule-independence-r-early-exit-premise1" "Independence Rule"
                       "Early Exit Failed or Premise Flags Incorrect.") "rule-independence-r-early-exit-premise1"))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Independence Left Rule Tests - Comprehensive - ENHANCED with Assertions - REFACTORED for modularity
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun test-rule-independence-l-premise1-incon ()
  (multiple-value-bind (rule-result premise-satisfied flags)
      (rule-independence-l *knowledge-base*)
    (declare (ignore flags))
    (assert-true (and (eq rule-result :rule-applied) (eq premise-satisfied :premise1-satisfied))
                 "rule-independence-l-premise1-incon" "Independence Rule"
                 (format nil "Expected (:rule-applied :premise1-satisfied), got (~A ~A)" rule-result premise-satisfied))
    (values (assert-true (and (eq rule-result :rule-applied) (eq premise-satisfied :premise1-satisfied))
                 "rule-independence-l-premise1-incon" "Independence Rule"
                 (format nil "Expected (:rule-applied :premise1-satisfied), got (~A ~A)" rule-result premise-satisfied)) "rule-independence-l-premise1-incon")))


(defun test-rule-independence-l-premise2-incon ()
  (let ((axiom-incon-count 0))
    (flet ((mock-axiom-incon-l (kb)
             (declare (ignore kb))
             (incf axiom-incon-count)
             (format t "    Mock axiom-incon-l called (count: ~A).~%" axiom-incon-count)
             (if (= axiom-incon-count 2)
                 :refuted
                 nil)))
      (multiple-value-bind (rule-result premise-satisfied flags)
          (rule-independence-l *knowledge-base* :axiom-incon #'mock-axiom-incon-l)
        (declare (ignore flags))
        (assert-true (and (eq rule-result :rule-applied) (eq premise-satisfied :premise2-satisfied))
                     "test-rule-independence-l-premise2-incon" "Independence Rule" ; Corrected test name here
                     (format nil "Expected (:rule-applied :premise2-satisfied), got (~A ~A)" rule-result premise-satisfied))
         (values (assert-true (and (eq rule-result :rule-applied) (eq premise-satisfied :premise2-satisfied))
                     "test-rule-independence-l-premise2-incon" "Independence Rule" ; Corrected test name here
                     (format nil "Expected (:rule-applied :premise2-satisfied), got (~A ~A)" rule-result premise-satisfied)) "test-rule-independence-l-premise2-incon")))))
;; Justification: mock-axiom-incon-l returns :refuted only on the second call, forcing rule-independence-l to apply via the second premise.


(defun test-rule-independence-l-negative ()
  (let ((axiom-incon-count 0))
    (flet ((mock-axiom-incon-l (kb)
             (declare (ignore kb))
             (incf axiom-incon-count)
             (format t "    Mock axiom-incon-l called (count: ~A) - (Negative Test - Never Refuted).~%" axiom-incon-count)
             nil))
      (multiple-value-bind (rule-result premise-satisfied flags)
          (rule-independence-l *knowledge-base* :axiom-incon #'mock-axiom-incon-l)
        (declare (ignore premise-satisfied flags))
        (assert-true (not (eq rule-result :rule-applied))
                     "rule-independence-l-negative" "Independence Rule"
                     (format nil "Expected NIL, got ~A" rule-result))
        (values (assert-true (not (eq rule-result :rule-applied))
                     "rule-independence-l-negative" "Independence Rule"
                     (format nil "Expected NIL, got ~A" rule-result)) "rule-independence-l-negative")))))


(defun test-rule-independence-l-early-exit-premise1 ()
  (let ((axiom-incon-count 0)
        (premise2-evaluated-flag nil))

    (flet ((mock-axiom-incon-l (kb)
             (declare (ignore kb))
             (incf axiom-incon-count)
             (format t "    Mock axiom-incon-l called (count: ~A) - (Early Exit Test).~%" axiom-incon-count)
             (if (= axiom-incon-count 1)
                 :refuted
                 (progn
                   (setf premise2-evaluated-flag t)
                   nil))))

      (multiple-value-bind (rule-result premise-satisfied flags)
          (rule-independence-l *knowledge-base* :axiom-incon #'mock-axiom-incon-l)
        (declare (ignore rule-result premise-satisfied))
        (let ((premise-flags (cdr (cdr (multiple-value-list (rule-independence-l *knowledge-base* :axiom-incon #'mock-axiom-incon-l))))))
          (assert-true (and (not premise2-evaluated-flag) (eq (car premise-flags) t) (eq (cadr premise-flags) nil))
                       "rule-independence-l-early-exit-premise1" "Independence Rule"
                       "Early Exit Failed or Premise Flags Incorrect.")
          (values (assert-true (and (not premise2-evaluated-flag) (eq (car premise-flags) t) (eq (cadr premise-flags) nil))
                       "rule-independence-l-early-exit-premise1" "Independence Rule"
                       "Early Exit Failed or Premise Flags Incorrect.") "rule-independence-l-early-exit-premise1"))))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Main Entry Point - Run the Prover Prototype and Tests
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun main ()
  "The main entry point for the script.
It first runs the full suite of unit tests using the categorical runners
and then executes the main `run-prover` function."
  (format t "Starting Barebones Theorem Prover Prototype.~%")

  (run-test-categories) ; Run unit tests - now with categories and summary

  (let ((prover-result (run-prover)))
    (format t "~%Prover Result: ~A~%" prover-result)
    (format t "Barebones Theorem Prover Prototype Finished.~%")))

(main)